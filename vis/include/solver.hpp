#pragma once

#include <tc/core.hpp>
#include <cmath>
#include <optional>
#include <numeric>
#include <iostream>

#include <geometry.hpp>

#include "combo_iterator.hpp"

/**
 * Produce a list of all generators for the group context. The range [0..group.rank()).
 */
std::vector<size_t> _generators(
    const tc::Group &context
) {
    std::vector<size_t> g_gens(context.rank());
    std::iota(g_gens.begin(), g_gens.end(), 0);
    return g_gens;
}

/**
 * Determine which of g_gens are the correct names for sg_gens within the current context
 *
 * For example if g_gens contains {a, b, c, d} and sg_gens contains {b, d, a} then the result is {1, 3, 0}
 */
std::vector<size_t> _recontext_gens(
    std::vector<size_t> g_gens,
    std::vector<size_t> sg_gens
) {
    auto orig = sg_gens;

    for (size_t &gen: sg_gens) {
        gen = std::distance(
            g_gens.begin(),
            std::find(g_gens.begin(), g_gens.end(), gen)
        );
    }
    return sg_gens;
}

/**
 * Convert the indexes of this mesh to those of a different context, using g_gens to build the parent context and sg_gens to build this context.
 */
template<unsigned N>
[[nodiscard]]
Indices<N> recontext(
    Indices<N> prims,
    const tc::Group &context,
    const std::vector<size_t> &g_gens,
    const std::vector<size_t> &sg_gens
) {
    const auto proper_sg_gens = _recontext_gens(g_gens, sg_gens);
    const auto table = context.sub(g_gens).solve({});
    const auto cosets = context.sub(sg_gens).solve({});

    tc::Path<size_t> path(cosets, proper_sg_gens);

    std::vector<size_t> map(path.order());
    path.walk(0, [&table](size_t coset, size_t gen) {
        return table.get(coset, gen);
    }, map.begin());

    Indices<N> res(prims);
    auto data = res.data();
    for (int i = 0; i < prims.size(); ++i) {
        data[i] = map[data[i]];
    }

    return res;
}

/**
 * Union several meshes of the same dimension
 */
template<unsigned N>
Indices<N> merge(
    const std::vector<Indices<N>> &meshes
) {
    size_t cols = 0;
    for (const auto &mesh: meshes) {
        cols += mesh.cols();
    }

    Indices<N> res(N, cols);

    size_t offset = 0;
    for (const Indices<N> &mesh: meshes) {
        res.middleCols(offset, mesh.cols()) = mesh;
        offset += mesh.cols();
    }

    return res;
}

template<unsigned N>
[[nodiscard]]
std::vector<Indices<N>> tile(
    Indices<N> prims,
    const tc::Group &context,
    const std::vector<size_t> &g_gens,
    const std::vector<size_t> &sg_gens
) {
    Indices<N> base = recontext<N>(prims, context, g_gens, sg_gens);
    const auto proper_sg_gens = _recontext_gens(g_gens, sg_gens);

    const auto &table = context.sub(g_gens).solve({});
    const auto &cosets = context.sub(g_gens).solve(proper_sg_gens);

    tc::Path<> path(cosets);

    std::vector<Indices<N>> res(path.order());

    path.walk(base, [&](Indices<N> from, auto gen) {
        for (int i = 0; i < from.size(); ++i) {
            from(i) = table.get(from(i), gen);
        }
        return from;
    }, res.begin());

    return res;
}

/**
 * Produce a mesh of higher dimension by fanning a single point to all primitives in this mesh.
 */
template<unsigned N>
[[nodiscard]]
Indices<N + 1> fan(
    Indices<N> prims,
    int root
) {
    Indices<N + 1> res(N + 1, prims.cols());

    res.topRows(1) = Indices<1>::Constant(1, prims.cols(), root);
    res.bottomRows(N) = prims;

    return res;
}

/**
 * Produce a mesh of primitives that fill out the volume of the subgroup generated by generators g_gens within the group context
 */
template<unsigned N>
Indices<N> triangulate(
    const tc::Group &context,
    const std::vector<size_t> &g_gens
) {
    if (g_gens.size() + 1 != N) // todo make static assert
        throw std::logic_error("g_gens size must be one less than N");

    const auto &combos = combinations(g_gens, g_gens.size() - 1);

    std::vector<Indices<N>> meshes;

    for (const auto &sg_gens: combos) {
        auto base = triangulate<N - 1>(context, sg_gens);
        auto parts = tile<N - 1>(base, context, g_gens, sg_gens);
        parts.erase(parts.begin(), parts.begin() + 1);
        auto raised = merge<N - 1>(parts);
        auto fanned = fan<N - 1>(raised, 0);
        meshes.push_back(fanned);
    }

    return merge<N>(meshes);
}

/**
 * Single-index primitives should not be further triangulated.
 */
template<>
Indices<1> triangulate<1>(
    const tc::Group &context,
    const std::vector<size_t> &g_gens
) {
    if (not g_gens.empty()) // todo make static assert
        throw std::logic_error("g_gens must be empty for a trivial Mesh");

    return Indices<1>::Zero(1, 1);
}

template<unsigned N, class T>
auto hull(
    const tc::Group &group,
    T all_sg_gens,
    const std::vector<std::vector<size_t>> &exclude
) {
    std::vector<Indices<N>> parts;
    auto g_gens = _generators(group);
    for (const std::vector<size_t> &sg_gens: all_sg_gens) {
        bool excluded = false;
        for (const auto &test: exclude) {
            if (sg_gens == test) {
                excluded = true;
                break;
            }
        }
        if (excluded) continue;

        const auto &base = triangulate<N>(group, sg_gens);
        const auto &tiles = tile<N>(base, group, g_gens, sg_gens);
        for (const auto &tile: tiles) {
            parts.push_back(tile);
        }
    }
    return parts;
}
