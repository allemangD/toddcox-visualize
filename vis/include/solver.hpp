#pragma once

#include <tc/core.hpp>
#include <cmath>
#include <optional>
#include <numeric>
#include <iostream>

#include <geometry.hpp>
#include <utility>

#include "combo_iterator.hpp"

/**
 * Produce a list of all generators for the group context. The range [0..group.ngens).
 */
std::vector<int> generators(const tc::Group &context) {
    std::vector<int> g_gens(context.ngens);
    std::iota(g_gens.begin(), g_gens.end(), 0);
    return g_gens;
}

namespace {
    /**
     * Determine which of g_gens are the correct names for sg_gens within the current context
     */
    std::vector<int> recontext_gens(
        const tc::Group &context,
        std::vector<int> g_gens,
        std::vector<int> sg_gens) {

        std::sort(g_gens.begin(), g_gens.end());

        int inv_gen_map[context.ngens];
        for (size_t i = 0; i < g_gens.size(); i++) {
            inv_gen_map[g_gens[i]] = i;
        }

        std::vector<int> s_sg_gens;
        s_sg_gens.reserve(sg_gens.size());
        for (const auto gen : sg_gens) {
            s_sg_gens.push_back(inv_gen_map[gen]);
        }
        std::sort(s_sg_gens.begin(), s_sg_gens.end());

        return s_sg_gens;
    }

    /**
     * Solve the cosets generated by sg_gens within the subgroup generated by g_gens of the group context
     */
    tc::Cosets solve(
        const tc::Group &context,
        const std::vector<int> &g_gens,
        const std::vector<int> &sg_gens
    ) {
        const auto proper_sg_gens = recontext_gens(context, g_gens, sg_gens);
        return context.subgroup(g_gens).solve(proper_sg_gens);
    }

    /**
     * Apply some context transformation to all primitives of this mesh.
     */
    template<unsigned N>
    void apply(const tc::Cosets &table, int gen, Prims<N> &mat) {
        auto data = mat.data();
        for (int i = 0; i < mat.size(); ++i) {
            data[i] = table.get(data[i], gen);
        }
    }
}

//template<unsigned N, class T>
//auto hull(const tc::Group &group, T all_sg_gens, const std::vector<std::vector<int>> &exclude) {
//    std::vector<Prims<N>> parts;
//    auto g_gens = generators(group);
//    for (const std::vector<int> &sg_gens : all_sg_gens) {
//        bool excluded = false;
//        for (const auto &test : exclude) {
//            if (sg_gens == test) {
//                excluded = true;
//                break;
//            }
//        }
//        if (excluded) continue;
//
//        const auto &base = triangulate<N>(group, sg_gens);
//        const auto &tiles = tile<N>(base, group, g_gens, sg_gens);
//        for (const auto &tile : tiles) {
//            parts.push_back(tile);
//        }
//    }
//    return parts;
//}

template<unsigned N>
class Mesh {
public:
    const tc::Group *g;  // todo this needs to be handled more consistently
    std::vector<int> ctx;
    Prims<N> prims;

    Mesh(const tc::Group &g_, std::vector<int> ctx_, size_t cols);

    Mesh(const tc::Group &g_, std::vector<int> ctx_);

    Mesh<N> recontext(std::vector<int> ctx_);

    std::vector<Mesh<N>> tile(const std::vector<int> &ctx_);

    Mesh<N + 1> fan(unsigned root);

    [[nodiscard]] size_t size() const { return prims.size(); }

    [[nodiscard]] size_t rows() const { return prims.rows(); }

    [[nodiscard]] size_t cols() const { return prims.cols(); }

    [[nodiscard]] unsigned *data() { return prims.data(); }

    [[nodiscard]] const unsigned *data() const { return prims.data(); }
};

template<class M>
M merge(const std::vector<M> &meshes) {
    if (meshes.empty()) throw std::logic_error("cannot merge an empty list of meshes");

    auto g = meshes[0].g;
    auto ctx = meshes[0].ctx;

    size_t cols = 0;
    for (const auto &mesh : meshes) {
        cols += mesh.prims.cols();
    }

    M res(*g, ctx, cols);

    size_t offset = 0;
    for (const auto &mesh : meshes) {
        res.prims.middleCols(offset, mesh.prims.cols()) = mesh.prims;
        offset += mesh.prims.cols();
    }

    return res;
}

template<unsigned N>
Mesh<N> Mesh<N>::recontext(std::vector<int> ctx_) {
    Mesh<N> res = *this;
    res.ctx = ctx_;

    const auto proper_sg_gens = recontext_gens(*g, res.ctx, ctx);
    const auto table = solve(*g, res.ctx, {});
    const auto path = solve(*g, ctx, {}).path;

    auto map = path.template walk<int, int>(0, proper_sg_gens, [table](int coset, int gen) {
        return table.get(coset, gen);
    });

    auto data = res.prims.data();
    for (int i = 0; i < res.prims.size(); ++i) {
        data[i] = map[data[i]];
    }

    return res;
}

template<unsigned N>
std::vector<Mesh<N>> Mesh<N>::tile(const std::vector<int> &ctx_) {
    auto base = recontext(ctx_);

    auto table = solve(*g, base.ctx, {});
    auto path = solve(*g, base.ctx, ctx).path;

    std::vector<Mesh<N>> res = path.template walk<Mesh<N>, int>(
        base, generators(*g),
        [&](Mesh<N> mesh, int gen) {
            apply<N>(table, gen, mesh.prims);
            return mesh;
        }
    );

    return res;
}

template<unsigned N>
Mesh<N + 1> Mesh<N>::fan(unsigned root) {
    Mesh<N + 1> res(*g, ctx, prims.cols());

    res.prims.topRows(1) = Prims<1>::Constant(1, prims.cols(), root);
    res.prims.bottomRows(N) = prims;

    return res;
}

template<unsigned N>
Mesh<N>::Mesh(const tc::Group &g_, std::vector<int> ctx_, size_t cols)
    : g(&g_), ctx(std::move(ctx_)) {
    prims.setZero(N, cols);
}

template<unsigned N>
Mesh<N>::Mesh(const tc::Group &g_, std::vector<int> ctx_)
    : g(&g_), ctx(std::move(ctx_)) {
    if (ctx.size() + 1 != N) // todo make static assert
        throw std::logic_error("ctx size must be one less than N");

    const auto &combos = Combos(ctx, ctx.size() - 1);

    std::vector<Mesh<N>> meshes;

    for (const auto &sctx : combos) {
        Mesh<N - 1> base(*g, sctx);
        auto parts = base.tile(ctx);
        parts.erase(parts.begin(), parts.begin() + 1);

        if (parts.empty()) continue;
        auto raised = merge(parts);

        auto fanned = raised.fan(0);
        meshes.push_back(fanned);
    }

    prims = merge(meshes).prims;
}

template<>
Mesh<1>::Mesh(const tc::Group &g_, std::vector<int> ctx_) : g(&g_), ctx(std::move(ctx_)) {
    if (not ctx.empty())
        throw std::logic_error("ctx must be empty for a trivial Mesh.");

    prims.setZero(1, 1);
}

template<unsigned N>
auto hull(const tc::Group &g, const std::vector<std::vector<int>> &exclude) {
    std::vector<Mesh<N>> parts;

    auto ctx = generators(g);
    auto sub_ctxs = Combos(ctx, N - 1);

    for (const auto &sub_ctx : sub_ctxs) {
        bool excluded = std::any_of(
            exclude.begin(), exclude.end(),
            [&](auto e) { return e == sub_ctx; }
        );
        if (excluded) continue;

        auto sub_parts = Mesh<N>(g, sub_ctx).tile(ctx);
        parts.insert(parts.end(), sub_parts.begin(), sub_parts.end());
    }

    return parts;
}